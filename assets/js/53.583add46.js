(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{473:function(t,a,r){t.exports=r.p+"assets/img/202307241941.4de01275.png"},958:function(t,a,r){"use strict";r.r(a);var e=r(27),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_19、spring中的八大模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19、spring中的八大模式"}},[t._v("#")]),t._v(" 19、Spring中的八大模式")]),t._v(" "),e("h3",{attrs:{id:"_19-1-简单工厂模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-1-简单工厂模式"}},[t._v("#")]),t._v(" 19.1 简单工厂模式")]),t._v(" "),e("ul",[e("li",[t._v("BeanFactory的getBean()方法，通过唯一标识来获取Bean对象，是典型的简单工厂模式（静态工厂模式）")])]),t._v(" "),e("h3",{attrs:{id:"_19-2-工厂方法模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-2-工厂方法模式"}},[t._v("#")]),t._v(" 19.2 工厂方法模式")]),t._v(" "),e("ul",[e("li",[t._v("FactoryBean是典型的工厂方法模式，在配置文件中通过factory-method属性来指定工厂方法，该方法是一个实例方法")])]),t._v(" "),e("h3",{attrs:{id:"_19-3-单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-3-单例模式"}},[t._v("#")]),t._v(" 19.3 单例模式")]),t._v(" "),e("ul",[e("li",[t._v("Spring用的是双重判断加锁的单例模式")])]),t._v(" "),e("p",[e("img",{attrs:{src:r(473),alt:"image.png"}})]),t._v(" "),e("h3",{attrs:{id:"_19-4-代理模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-4-代理模式"}},[t._v("#")]),t._v(" 19.4 代理模式")]),t._v(" "),e("ul",[e("li",[t._v("Spring的AOP就是使用了动态代理实现的")])]),t._v(" "),e("h3",{attrs:{id:"_19-5-装饰器模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-5-装饰器模式"}},[t._v("#")]),t._v(" 19.5 装饰器模式")]),t._v(" "),e("ul",[e("li",[t._v("JavaSE的IO流中是非常典型的装饰器模式")]),t._v(" "),e("li",[t._v("Spring 中配置 DataSource 的时候，这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。")]),t._v(" "),e("li",[t._v("这时，能否在尽可能少修改原有类代码下的情况下，做到动态切换不同的数据源？此时就可以用到装饰者模式。")]),t._v(" "),e("li",[t._v("Spring根据每次请求的不同，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。")]),t._v(" "),e("li",[e("strong",[t._v("Spring中类名中带有：Decorator和Wrapper单词的类，都是装饰器模式。")])])]),t._v(" "),e("h3",{attrs:{id:"_19-6-观察者模式、"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-6-观察者模式、"}},[t._v("#")]),t._v(" 19.6 观察者模式、")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。Spring中观察者模式一般用在listener的实现。")])]),t._v(" "),e("li",[e("p",[t._v("Spring中的事件编程模型就是观察者模式的实现。在Spring中定义了一个ApplicationListener接口，用来监听Application的事件，Application其实就是ApplicationContext，ApplicationContext内置了几个事件，其中比较容易理解的是：ContextRefreshedEvent、ContextStartedEvent、ContextStoppedEvent、ContextClosedEvent")])])]),t._v(" "),e("h3",{attrs:{id:"_19-7-策略模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-7-策略模式"}},[t._v("#")]),t._v(" 19.7 策略模式")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。")])]),t._v(" "),e("li",[e("p",[t._v("getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。")])]),t._v(" "),e("li",[e("p",[t._v("比如我们自己写了AccountDao接口，然后这个接口下有不同的实现类：AccountDaoForMySQL，AccountDaoForOracle。对于service来说不需要关心底层具体的实现，只需要面向AccountDao接口调用，底层可以灵活切换实现，这就是策略模式。")])])]),t._v(" "),e("h3",{attrs:{id:"_19-8-模板方法模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-8-模板方法模式"}},[t._v("#")]),t._v(" 19.8 模板方法模式")]),t._v(" "),e("ul",[e("li",[t._v("Spring中的JdbcTemplate类就是一个模板类。它就是一个模板方法设计模式的体现。在模板类的模板方法execute中编写核心算法，具体的实现步骤在子类中完成。")])])])}),[],!1,null,null,null);a.default=_.exports}}]);