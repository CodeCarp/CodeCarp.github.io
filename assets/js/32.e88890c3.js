(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{1055:function(s,t,_){"use strict";_.r(t);var e=_(27),v=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"redis集群-cluster"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis集群-cluster"}},[s._v("#")]),s._v(" Redis集群（cluster）")]),s._v(" "),e("h3",{attrs:{id:"_10-1-集群定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-集群定义"}},[s._v("#")]),s._v(" 10.1 集群定义")]),s._v(" "),e("blockquote",[e("p",[s._v("由于数据量过大，单个"),e("code",[s._v("master")]),s._v("复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是"),e("code",[s._v("redis")]),s._v("集群，其作用是提供在多个"),e("code",[s._v("redis")]),s._v("节点间共享数据的程序集。")]),s._v(" "),e("p",[e("code",[s._v("Redis")]),s._v("支持多个"),e("code",[s._v("master")]),s._v("。")])]),s._v(" "),e("p",[e("img",{attrs:{src:_(643),alt:"image-20230504115753572"}})]),s._v(" "),e("h3",{attrs:{id:"_10-2-redis集群的槽位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-redis集群的槽位"}},[s._v("#")]),s._v(" 10.2 Redis集群的槽位")]),s._v(" "),e("blockquote",[e("p",[e("code",[s._v("Redis")]),s._v("集群没有使用一致性"),e("code",[s._v("hash")]),s._v("，而是引入了哈希槽的概念。")]),s._v(" "),e("p",[e("code",[s._v("Redis")]),s._v("集群有"),e("code",[s._v("16384")]),s._v("个哈希槽，每个"),e("code",[s._v("key")]),s._v("通过"),e("code",[s._v("CRC16")]),s._v("校验后对"),e("code",[s._v("16384")]),s._v("取模来决定放置哪个槽，集群的每个节点负责一部分"),e("code",[s._v("hash")]),s._v("槽。")])]),s._v(" "),e("p",[e("img",{attrs:{src:_(644),alt:"image-20230504124654146"}})]),s._v(" "),e("h3",{attrs:{id:"_10-3-redis集群的分片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-3-redis集群的分片"}},[s._v("#")]),s._v(" 10.3 Redis集群的分片")]),s._v(" "),e("blockquote",[e("p",[s._v("**分片是什么：**使用redis集群时我们会将存储的数据分散到多台redis机器上，这称为分片。简言之，集群中的每个redis实例都被认为是整个数据的一个分片。")]),s._v(" "),e("p",[s._v("**分片与槽位的优势：**最大优势，方便扩容和数据分派查找。这种结构很容易添加或者删除节点，比如如果我想添加个节点D，我需要从节点A，B，C中得部分槽位到D上。如果我想一出节点A，需要将A中的槽移动到B和C节点上，然后将没有任何槽的节点从集群中移除即可。由于一个结点将哈希槽移动到另一个节点不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。")])]),s._v(" "),e("h3",{attrs:{id:"_10-4-slot槽位映射"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-slot槽位映射"}},[s._v("#")]),s._v(" 10.4 slot槽位映射")]),s._v(" "),e("blockquote",[e("p",[e("strong",[s._v("一般有3中解决方案：1.哈希取余分区；2.一致性哈希算法分区；3.哈希槽分区。")])])]),s._v(" "),e("h4",{attrs:{id:"_10-4-1-哈希取余分区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-1-哈希取余分区"}},[s._v("#")]),s._v(" 10.4.1 哈希取余分区")]),s._v(" "),e("p",[e("img",{attrs:{src:_(645),alt:"image-20230505170739861"}})]),s._v(" "),e("blockquote",[e("p",[s._v("2亿条记录即使2亿个"),e("code",[s._v("k,v")]),s._v("。我们单击不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式："),e("code",[s._v("hash(key)%N个机器台数")]),s._v("，计算出哈希值，用来决定数据映射到哪一个节点上。、")]),s._v(" "),e("p",[s._v("**优点：**简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台，8台，10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请（并维护这些请求的信息），起到负载均衡+分而治之的作用。")]),s._v(" "),e("p",[s._v("**缺点：**原来规划好的节点，进行扩容或者缩容就比较麻烦了，不管扩容，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化："),e("code",[s._v("Hash(key)/3会变成Hash(key)/?")]),s._v("。此时某个"),e("code",[s._v("redis")]),s._v("机器宕机了，由于台数数量变化，会导致"),e("code",[s._v("hash")]),s._v("取余全部数据重新洗牌。")])]),s._v(" "),e("h4",{attrs:{id:"_10-4-2-一致性哈希算法分区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-2-一致性哈希算法分区"}},[s._v("#")]),s._v(" 10.4.2 一致性哈希算法分区")]),s._v(" "),e("blockquote",[e("p",[s._v("目的：当前服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。")]),s._v(" "),e("p",[s._v("3大步骤：1.算法构建一致性哈希环；2.服务器IP节点映射；3."),e("code",[s._v("key")]),s._v("落到服务器的落键规则。")]),s._v(" "),e("p",[s._v("缺点：一致性哈希算法的数据倾斜问题。")])]),s._v(" "),e("h4",{attrs:{id:"_10-4-3-哈希槽"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-3-哈希槽"}},[s._v("#")]),s._v(" 10.4.3 哈希槽")]),s._v(" "),e("blockquote",[e("p",[s._v("哈希槽实际就是一个数组，数组"),e("code",[s._v("[0~2^14-1]")]),s._v("形成"),e("code",[s._v("hash slot")]),s._v("空间。")]),s._v(" "),e("p",[s._v("能解决均匀分配的问题，在数据和节点之间又加了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里边放的是数据。")])]),s._v(" "),e("p",[e("img",{attrs:{src:_(646),alt:"image-20230505184541962"}})]),s._v(" "),e("blockquote",[e("p",[s._v("槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动，哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。")])]),s._v(" "),e("h4",{attrs:{id:"_10-4-5-为什么redis集群的最大槽数是16384个"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-5-为什么redis集群的最大槽数是16384个"}},[s._v("#")]),s._v(" 10.4.5 为什么redis集群的最大槽数是16384个")]),s._v(" "),e("blockquote",[e("p",[s._v("Redis集群并没有使用一致性hash而是引入了哈希槽的概念。Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的没个节点负责一部分hash槽。但为什么哈希槽的数量是16384（2^14）个呢？")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("如果槽位位65535，发送心跳信息的消息头达8K，发送的心跳包过于庞大；")])])]),s._v(" "),e("p",[s._v("在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。当槽位为65536时，这块的大小是:65536÷8÷1024=8kb")]),s._v(" "),e("p",[s._v("在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。当槽位为16384时，这块的大小是:16384∶8∶1024=2kb")]),s._v(" "),e("p",[s._v("因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。")]),s._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("strong",[s._v("redis集群主节点数量基本不可能超过1000个；")])])]),s._v(" "),e("p",[s._v("集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。")]),s._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("strong",[s._v("槽位越小，节点少的情况下，压缩比高，容易传输。")])])]),s._v(" "),e("p",[s._v("Redis主节点的配置信息中它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率slots /N很高的话(N表示节点数)， bitmap的压缩率就很低。如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。")])])])}),[],!1,null,null,null);t.default=v.exports},643:function(s,t,_){s.exports=_.p+"assets/img/image-20230504115753572.985eaed3.png"},644:function(s,t,_){s.exports=_.p+"assets/img/image-20230504124654146.91e236df.png"},645:function(s,t,_){s.exports=_.p+"assets/img/image-20230505170739861.e266eb6c.png"},646:function(s,t,_){s.exports=_.p+"assets/img/image-20230505184541962.16696d45.png"}}]);